[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello! My name is Aspen Raine Reynolds and I am currently a junior at the University of Nebraska-Lincoln. I’m majoring in advertising and public relations, broadcasting & sports media and communications with minors in art, art history and criticism, geography and global studies. At the University, I study in the College of Journalism and Mass Communications. The project based classes have allowed me to gain and practice a wide variety of skills including the Adobe Creative Cloud, AP Style writing, audio, graphic design, photography, videography and more.\nApart from my studies, I work with Husker Motorsport. It’s a campus-based club where students build a Formula SAE regulation car and compete with other universities around the world. I work on their public relations & social media side which allows me to both gain experience for my future career, as well as understand how the car itself functions. Getting to work closely with the engineering students allows me to see the car development from start to finish while getting to document it.\nI also have an interest in management, and helping younger athletes in sports stay protected is a huge passion of mine. Being able to use my skills to help teams and athletes is my dream. The world of sports and social media can be very intense, and I want to do everything I can to make that a little less scary.\nAfter I graduate, I plan to move overseas to work in motorsport, with the ultimate goal of working in Formula 1 or 2. I have always loved travelling, and getting to see the world while also working would be a dream. I love seeing new places, learning about new cultures and meeting people from around the world, and working in motorsport would allow me to do that. It combines everything I’m passionate about, and also lets me use the skills I’ve gained with my education."
  },
  {
    "objectID": "f1dataR/inst/doc/jolpica-data-analysis.html",
    "href": "f1dataR/inst/doc/jolpica-data-analysis.html",
    "title": "Jolpica Data Analysis",
    "section": "",
    "text": "This vignette provides a few demonstrations of possible data analysis projects using f1dataR and the data pulled from the Jolpica API. All of the data used comes from Jolpica and is not supplied by Formula 1. However, this data source is incredibly useful for accessing a host of data.\nThis package (and vignette) previously used the Ergast Motor Racing Database. Unfortunately, Ergast was shuttered in 2024. Jolpica was developed as a direct replacement.\nWe’ll load all the required libraries for our data analysis:\nlibrary(f1dataR)\nlibrary(dplyr)"
  },
  {
    "objectID": "f1dataR/inst/doc/jolpica-data-analysis.html#grid-to-finish-position-correlation",
    "href": "f1dataR/inst/doc/jolpica-data-analysis.html#grid-to-finish-position-correlation",
    "title": "Jolpica Data Analysis",
    "section": "Grid to Finish Position Correlation",
    "text": "Grid to Finish Position Correlation\nWe can look at the correlation between the starting (grid) position and the race finishing position. We’ll look at the Austrian Grand Prix from 2020 for this analysis, not because of any particular reason, but that it produced a well mixed field.\nlibrary(ggplot2)\n# Load the data\nresults &lt;- load_results(2020, 1) %&gt;%\n  mutate(\n    grid = as.numeric(grid),\n    position = as.numeric(position)\n  )\n\nggplot(results, aes(x = position, y = grid)) +\n  geom_point(color = \"white\") +\n  stat_smooth(method = \"lm\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2020 Austrian Grand Prix Grid - Finish Position\") +\n  xlab(\"Finish Position\") +\n  ylab(\"Grid Position\")\n\n\n\nA plot of grid position (y axis) vs race finishing position (x axis) for the 2020 Austrian Grand Prix\n\n\nOf course, this isn’t really an interesting plot for a single race. Naturally we expect that a better grid position yields a better finish position, but there’s so much variation in one race (including the effect of DNF) that it’s a very weak correlation. We can look at the whole season instead by downloading sequentially the list of results. We’ll filter the results to remove those who didn’t finish the race, and also those who didn’t start from the grid (i.e. those who started from Pit Lane, where grid = 0).\n# Load the data\nresults &lt;- data.frame()\nfor (i in seq_len(17)) {\n  Sys.sleep(1)\n  r &lt;- load_results(2022, i)\n  results &lt;- dplyr::bind_rows(results, r)\n}\n\nresults &lt;- results %&gt;%\n  mutate(\n    grid = as.numeric(grid),\n    position = as.numeric(position)\n  ) %&gt;%\n  filter(status %in% c(\"Finished\", \"+1 Lap\", \"+2 Laps\", \"+6 Laps\"), grid &gt; 0)\n\nggplot(results, aes(y = position, x = grid)) +\n  geom_point(color = \"white\", alpha = 0.2) +\n  stat_smooth(method = \"lm\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2020 F1 Season Grid - Finish Position\") +\n  ylab(\"Finish Position\") +\n  xlab(\"Grid Position\")\n\n\n\nA plot of grid position (y axis) vs race finishing position (x axis) for all 2020 Grands Prix\n\n\nAs expected, this produces a much stronger signal confirming our earlier hypothesis."
  },
  {
    "objectID": "f1dataR/inst/doc/jolpica-data-analysis.html#driver-points-progress",
    "href": "f1dataR/inst/doc/jolpica-data-analysis.html#driver-points-progress",
    "title": "Jolpica Data Analysis",
    "section": "Driver Points Progress",
    "text": "Driver Points Progress\nJolpica contains the points for drivers’ or constructors’ championship races as of the end of every round in a season. We can pull a season’s worth of data and compare the driver pace throughout the season, looking at both position or total points accumulation. We’ll do that for 2021, which had good competition throughout the year for P1.\n# Load the data\npoints &lt;- data.frame()\nfor (rnd in seq_len(22)) {\n  p &lt;- load_standings(season = 2021, round = rnd) %&gt;%\n    mutate(round = rnd)\n  points &lt;- rbind(points, p)\n  Sys.sleep(1)\n}\n\npoints &lt;- points %&gt;%\n  mutate(\n    position = as.numeric(position),\n    points = as.numeric(points)\n  )\n\n# Plot the Results\nggplot(points, aes(x = round, y = position, color = driver_id)) +\n  geom_line() +\n  geom_point(size = 1) +\n  ggtitle(\"Driver Position\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Position\") +\n  scale_y_reverse(breaks = seq_along(length(unique(points$position)))) +\n  theme_dark_f1(axis_marks = TRUE)\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_line()`).\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\nDriver ranking after each Grand Prix of the 2021 season\n\n\nWhat may be more interesting is the total accumulation of points. For that we can change up the plot just a little bit.\n# Plot the Results\nggplot(points, aes(x = round, y = points, color = driver_id)) +\n  geom_line() +\n  geom_point(size = 1) +\n  ggtitle(\"Driver Points\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Points\") +\n  theme_dark_f1(axis_marks = TRUE)\n\n\n\nTotal points for each driver after each Grand Prix in the 2021 season\n\n\nBoth of these are a bit hard to read and use driver_id values that aren’t pretty on the plot. We can use some of the FastF1 look-up functions to improve our graphics (recalling that Kubica raced for Alfa Romeo for races 13 & 14 mid-season). We’ll first build a data.frame of all drivers and styles for the season, and join that to the points data.frame after we generate driver abbreviations from the Jolpica driver_id.\ndriver_style &lt;- rbind(\n  get_session_drivers_and_teams(2021, round = 1),\n  get_session_drivers_and_teams(2021, round = 13)\n) %&gt;%\n  unique()\n\ndriver_style$linestyle &lt;- driver_style$marker &lt;- driver_style$color &lt;- driver_style$abbreviation &lt;- NA\n\nfor (i in seq_along(driver_style$name)) {\n  if (driver_style$name[i] == \"Robert Kubica\") {\n    # Manually handling Kubica\n    style &lt;- get_driver_style(driver_style$name[i], season = 2021, round = 13)\n    driver_style$color[i] &lt;- style$color\n    driver_style$marker[i] &lt;- 2\n    driver_style$linestyle[i] &lt;- \"dotted\"\n    driver_style$abbreviation[i] &lt;- style$abbreviation\n  } else {\n    style &lt;- get_driver_style(driver_style$name[i], season = 2021, round = 1)\n    driver_style$color[i] &lt;- style$color\n    driver_style$marker[i] &lt;- style$marker\n    driver_style$linestyle[i] &lt;- style$linestyle\n    driver_style$abbreviation[i] &lt;- style$abbreviation\n  }\n}\n\ncolor_values &lt;- driver_style$color\nnames(color_values) &lt;- driver_style$abbreviation\n\nmarker_values &lt;- driver_style$marker\nnames(marker_values) &lt;- driver_style$abbreviation\n\nlinestyle_values &lt;- driver_style$linestyle\nnames(linestyle_values) &lt;- driver_style$abbreviation\n\npoints &lt;- dplyr::left_join(points, load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\")\nWith our data having graphical and label information added, we can remake these plots:\nggplot(points, aes(x = round, y = points, color = code, shape = code, linetype = code)) +\n  geom_line() +\n  geom_point() +\n  scale_color_manual(name = \"Driver\", values = color_values, aesthetics = c(\"color\", \"fill\")) +\n  scale_shape_manual(name = \"Driver\", values = marker_values) +\n  scale_linetype_manual(name = \"Driver\", values = linestyle_values) +\n  ggtitle(\"Driver Points\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Points\") +\n  theme_dark_f1(axis_marks = TRUE)\n\n\n\nRemade points plot for each driver after each Grand Prix in the 2021 season, with better driver names and colors"
  },
  {
    "objectID": "f1dataR/inst/doc/jolpica-data-analysis.html#driver-lap-time-scatter-plot",
    "href": "f1dataR/inst/doc/jolpica-data-analysis.html#driver-lap-time-scatter-plot",
    "title": "Jolpica Data Analysis",
    "section": "Driver Lap Time Scatter Plot",
    "text": "Driver Lap Time Scatter Plot\nWe can look at a scatterplot of a driver’s laptimes throughout a race - possibly observing the effect of fuel usage, tire wear, pit stops, and race conditions. We’ll also show extracting constructor colour from the built-in data set.\n# Load the laps data and select one driver (this time - Russell)\nbot &lt;- load_laps(season = 2021, round = 4) %&gt;%\n  filter(driver_id == \"bottas\")\n\n# Get Grand Prix Name\nracename &lt;- load_schedule(2021) %&gt;%\n  filter(round == 4) %&gt;%\n  pull(\"race_name\")\n\nracename &lt;- paste(racename, \"2021\")\n\n# Plot the results\nggplot(bot, aes(x = lap, y = time_sec)) +\n  geom_point(color = get_driver_color(\"Bottas\", 2021, 4)) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"Bottas Lap times through the Grand Prix\", subtitle = racename) +\n  xlab(\"Lap Number\") +\n  ylab(\"Lap Time (s)\")\n\n\n\nLaptimes for George Russell, for each lap from the 2021 Spanish Grand Prix\n\n\nWe can see the most of Bottas’ laps were less than 90 seconds. Note a safety car had occurred around lap 8.\nWith the above data, we can also visualize all driver’s laptimes with violin plots. We’ll trim the laptimes to exclude anything above 100 seconds to make the variation in lap time easier to see (i.e. show only racing laps). We can recycle the color values we produced above.\n# Load the laps data (cached!) and filter\nlaps &lt;- load_laps(season = 2021, round = 4) %&gt;%\n  filter(time_sec &lt; 100) %&gt;%\n  group_by(driver_id) %&gt;%\n  mutate(driver_avg = mean(time_sec)) %&gt;%\n  ungroup() %&gt;%\n  left_join(load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\") %&gt;%\n  mutate(code = factor(code, unique(code[order(driver_avg)])))\n\nggplot(laps, aes(x = code, y = time_sec, color = code, fill = code)) +\n  geom_violin(trim = FALSE) +\n  scale_color_manual(\"Driver\", values = color_values, aesthetics = c(\"color\", \"fill\")) +\n  geom_boxplot(width = 0.1, color = \"black\", fill = \"white\", outlier.shape = NA) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"Driver Lap Times\", subtitle = paste(\"Racing Laps Only -\", racename)) +\n  xlab(\"Driver ID\") +\n  ylab(\"Lap Time (s)\") +\n  theme(axis.text.x = element_text(angle = 90), legend.position = \"\")\n\n\n\nLaptime distributions for all drivers from the 2021 Spanish Grand Prix (racing laps only)"
  },
  {
    "objectID": "f1dataR/inst/doc/jolpica-data-analysis.html#compare-qualifying-times",
    "href": "f1dataR/inst/doc/jolpica-data-analysis.html#compare-qualifying-times",
    "title": "Jolpica Data Analysis",
    "section": "Compare Qualifying Times",
    "text": "Compare Qualifying Times\nWe can compare the qualifying times for all drivers from a Grand Prix. There’s naturally a few ways to do this (pick each driver’s fastest time, pick each driver’s fastest time from the last session they participated in, etc), all with pros or cons. Rerunning this analysis with different ways of handling the data could produce different results!\n# Load the Data\nquali &lt;- load_quali(2021, 8)\n\n# Get Grand Prix Name\nracename &lt;- load_schedule(2021) %&gt;%\n  filter(round == 8) %&gt;%\n  pull(\"race_name\")\n\n# Process the Data\nquali &lt;- quali %&gt;%\n  summarize(t_min = min(q1_sec, q2_sec, q3_sec, na.rm = TRUE), .by = driver_id) %&gt;%\n  mutate(t_diff = t_min - min(t_min)) %&gt;%\n  left_join(load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\") %&gt;%\n  mutate(code = factor(code, unique(code[order(-t_min)])))\n\n# Plot the results\nggplot(quali, aes(x = code, y = t_diff, color = code, fill = code)) +\n  geom_col() +\n  coord_flip() +\n  ggtitle(paste0(racename, \" 2021 Quali Time Comparison\"),\n    subtitle = paste(\"VER Pole time:\", min(quali$t_min), \"s\")\n  ) +\n  scale_color_manual(values = color_values, aesthetics = c(\"fill\", \"color\")) +\n  ylab(\"Gap to Pole (s)\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(legend.position = \"\")\n\n\n\nGap to Pole at the end of qualifying for the 2021 Styrian Grand Prix"
  },
  {
    "objectID": "f1dataR/inst/doc/plotting-turn-info.html",
    "href": "f1dataR/inst/doc/plotting-turn-info.html",
    "title": "Plotting with FastF1 Circuit Information",
    "section": "",
    "text": "Introduction\nThis vignette provides a few demonstrations of the use of FastF1 circuit data in generating plots.\nWe’ll load all the required libraries for our data analysis:\nlibrary(f1dataR)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\nTelemetry Plotting\nAs in our Introduction vignette, we’ll start by working with telemetry data.\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\")\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\")\n\ntelem &lt;- bind_rows(lec, ham, per) %&gt;%\n  select(rpm, speed, n_gear, throttle, brake, drs, distance, time, driver_code) %&gt;%\n  mutate(drs = ifelse(drs == 12, 1, 0))\n\ndrivercolours &lt;- c(\n  \"LEC\" = get_driver_color(\"LEC\", 2022, 1),\n  \"HAM\" = get_driver_color(\"HAM\", 2022, 1),\n  \"PER\" = get_driver_color(\"PER\", 2022, 1)\n)\nTo demonstrate the addition of turn information, we’ll start by plotting the speed telemetry for the three drivers\ntelem_plot_speed &lt;- ggplot(telem, aes(x = distance, y = speed, color = driver_code)) +\n  geom_path() +\n  scale_color_manual(values = drivercolours) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2022 Bahrain Grand Prix Qualifying Telemetry\", subtitle = \"Speed vs Distance in lap\") +\n  xlab(\"Distance (m)\") +\n  ylab(\"Speed\") +\n  labs(color = \"Driver\")\n\ntelem_plot_speed\n\n\n\nSpeed by Distance for Leclerc, Hamilton and Perez after qualifying best laps\n\n\nNow, to add the corner numbers to a plot like this, we’ll have to retrieve those from FastF1.\nbahrain_circuit &lt;- load_circuit_details(2022, 1)\nbahrain_corners &lt;- bahrain_circuit$corners\n\nspeedmax &lt;- max(telem$speed, na.rm = TRUE)\nspeedmin &lt;- min(telem$speed, na.rm = TRUE)\nNow we can add these indicators to the previous plot:\ntelem_plot_speed +\n  geom_vline(xintercept = bahrain_corners$distance, linetype = \"longdash\", color = \"#646464\") +\n  geom_label(data = bahrain_corners, aes(\n    label = paste0(number, letter),\n    y = speedmin - 10,\n    x = distance,\n    color = \"#9A9A9A\"\n  ), show.legend = FALSE)\n\n\n\nSpeed by distance plot as above, but with turn numbres added\n\n\nOf course, these labels overlap slightly for turns close together (1-3, 5-7, 9-10, 14-15). Other packages such as ggrepel can handle these situations better, but are not the point of this demonstration.\n\n\nPlotting Turn Number On Track\nSimilar to the plotting of turn numbers on telemetry, we can add these annotations to the typical track plot.\nWe’ll work with 2022 Silverstone (British Grand Prix) for this plot. Lets’ start by getting the data:\nver &lt;- load_driver_telemetry(season = 2022, round = \"Silverstone\", session = \"Q\", driver = \"VER\", laps = \"fastest\")\nsilverstone_circuit &lt;- load_circuit_details(season = 2022, round = \"Silverstone\")\nNow we’ll plot it. Look to the bottom of the code to see the addition of labels.\ngear_plot &lt;- ggplot(ver, aes(x, y, color = as.factor(n_gear), group = NA)) +\n  geom_path(linewidth = 4, lineend = \"round\") +\n  ggplot2::scale_color_manual(\n    name = \"Gear\",\n    values = c(\n      \"1\" = \"#BC3C29\", \"2\" = \"#0072B5\", \"3\" = \"#E18727\", \"4\" = \"#20854E\",\n      \"5\" = \"#7876B1\", \"6\" = \"#6F99AD\", \"7\" = \"#FFDC91\", \"8\" = \"#EE4C97\"\n    ),\n    aesthetics = c(\"color\", \"fill\")\n  ) +\n  theme_dark_f1() +\n  labs(\n    title = \"British Grand Prix 2022\",\n    subtitle = \"Gear in use by Verstappen in Quali\",\n    color = \"Gear\"\n  )\nlabelled_gear_plot &lt;- gear_plot +\n  geom_label(data = silverstone_circuit$corners, aes(\n    label = paste0(number, letter),\n    y = y,\n    x = x,\n    color = \"#9A9A9A\"\n  ), show.legend = FALSE)\n\ncorrect_track_ratio(labelled_gear_plot)\n\n\n\nGear selected by Verstappen during his Silverstone fastest qualifying lap\n\n\nLike before, the plot has some issues with overlap. But this time, beyond using ggrepel, we have the data provided to move the labels in a ‘pretty’ way.\nThe data returned by get_circuit_data() includes an extra column (angle) that can be used to determine an adequate shift angle for the label. With that data, and some careful math, we can move the labels to where we want them.\nlabelx &lt;- function(x, angle, distance = 750) {\n  angle &lt;- angle * pi / 180\n  return(cos(angle) * distance + x)\n}\nlabely &lt;- function(y, angle, distance = 750) {\n  angle &lt;- angle * pi / 180\n  return(sin(angle) * distance + y)\n}\n\nsilverstone_circuit$corners$labx &lt;- labelx(silverstone_circuit$corners$x, silverstone_circuit$corners$angle)\nsilverstone_circuit$corners$laby &lt;- labely(silverstone_circuit$corners$y, silverstone_circuit$corners$angle)\nWith those new label x and y points calculated, we can re-plot the labels slightly offset from the track.\nlabelled_gear_plot2 &lt;- gear_plot +\n  geom_label(data = silverstone_circuit$corners, aes(\n    label = paste0(silverstone_circuit$corners$number, silverstone_circuit$corners$letter),\n    y = silverstone_circuit$corners$laby,\n    x = silverstone_circuit$corners$labx,\n    color = \"white\",\n  ), size = 3, label.padding = unit(0.15, \"lines\"), show.legend = FALSE)\n\ncorrect_track_ratio(labelled_gear_plot2)\n\n\n\nPlot showing gear in use by Vertappen around Silversone, with corner labels applied\n\n\nFurther exploration (including label repelling) is left to the reader."
  },
  {
    "objectID": "f1dataR/inst/doc/setup_fastf1.html",
    "href": "f1dataR/inst/doc/setup_fastf1.html",
    "title": "Setup FastF1 Connection",
    "section": "",
    "text": "This vignette briefly describes setting up the f1dataR package to work properly with with the Python package FastF1. This guide may help resolve some issues that might arise when you get the following warning or error messages:\n\nEnsure fastf1 python package is installed. Please run this to install the most recent version: setup_fastf1()\nError in if (get_fastf1_version() &lt; '3.1') { : missing value where TRUE/FALSE needed\n\nIf these happen to you (particularly if you’re a new user of f1dataR) read on!"
  },
  {
    "objectID": "f1dataR/inst/doc/setup_fastf1.html#accept-all-defaults",
    "href": "f1dataR/inst/doc/setup_fastf1.html#accept-all-defaults",
    "title": "Setup FastF1 Connection",
    "section": "Accept all defaults",
    "text": "Accept all defaults\nTo use all of the defaults and set up the reticulate package, you can use the below helper function.\nsetup_fastf1()\nThis will create a virtual environment using your system’s default Python version, and install fastf1 in that python environment. It will also tell reticulate to use that environment instead of just running in your main system. Many resources exist online to explain python environments in more detail."
  },
  {
    "objectID": "f1dataR/NEWS.html",
    "href": "f1dataR/NEWS.html",
    "title": "f1dataR 2.0.1",
    "section": "",
    "text": "f1dataR 2.0.1\n\nForced fail-over from Ergast to Jolpica (still deprecated at ‘warn’ level).\nFixed a pre-season bug where Jolpica API was missing a column in load_season().\nFixed a bug resulting from a change in API for 2025 season - Thanks to @appiehappie999 (#277)\n\n\n\nf1dataR 2.0.0\n\nDeprecated Ergast and moved to Jolpica API for Ergast Functions. While this is not a breaking change in the code syntax, the documentation changes significantly to reflect this and a new major version is appropriate. (#268)\nBugfix in plot_fastest().\nBugfix in load_results() with pagination - Thanks to @awanderingspirit. (#272)\nBugfix in README. (#267)\n\n\n\nf1dataR 1.6.0\n\nUpdates per FastF1 (python) updates at 3.4.0 #259\n\nSoft deprecates FastF1 v &lt; 3.4.0, hard deprecates FastF1 v &lt; 3.1.0.\nAdded functions to get driver graphic style & team colors from FastF1. See get_driver_style(), get_driver_color(), get_team_color() and get_driver_color_map() (and the aliases with colour).\nAdded functions for look-ups of driver & team information for seasons/sessions. See get_driver_abbreviation(), get_driver_name(), get_team_by_driver(), get_team_name(), get_drivers_by_team().\nRemoved constructor_data object from package vignettes, readme, examples, etc.\nExpanded vignettes to improve graphics & demonstrate lookups.\n\nRemoved usethis from Suggests (only needed when changing data)\nUpdated tests to avoid API failure for 2022 season & better skip-on-CRAN for internet resources\nUpdated minimum R to 3.5.0, reflecting imported package requirements.\n\n\n\nf1dataR 1.5.3\n\nEnabled Sprint Qualifying “SQ” as a session type in line with FastF1 v3.3.5.\n\n\n\nf1dataR 1.5.2\n\nModified testing to satisfy CRAN requirements.\nAdded vignette looking at telemetry plots through Alonso’s 2024 Australia penalty.\n\n\n\nf1dataR 1.5.1\n\nAdded (very soft) deprecation warning to Ergast functions in advance of the Ergast API being defunct in less than 12 months.\nDeprecated support for FastF1 v &lt; 3.1.0. Older FastF1 versions do not support all of the functions in use and may return different values from some data retrieval or calculation functions. Forcing use of up-to-date FastF1 allows for simpler bugfixes and code updates. (#198)\nRemoved Ergast check for get_current_season() (#227)\nImproved messaging to users regarding updating FastF1 (#226)\nNamed items in list returned by load_circuit_details()\nChanged the way that correct_track_ratio() works. Visually the results are the same, but now any labels/annotations added to the ggplot should be kept in the right spot.\nAdded Vignette describing some load_circuit_details() usage.\nCode improvements (better handle variation in Ergast response, better handle Ergast connection failures) (#228)\nTesting improvements to validate our handling of internet failures (#228)\nUpgraded to use httptest2 for testing no-internet scenarios (no affect on package performance)\nCode cleanup (removed old inaccessible code, centralized repeated steps to functions, etc.)\n\n\n\nf1dataR 1.5.0\n\nAdded load_circuit_details (#210)\nStrengthened package testing (#212, #216)\nBugfixes (#216)\n\n\n\nf1dataR 1.4.1\n\nFixed a bug with cache options (#194, #195, #197)\nFixed a build bug\nBegan deprecation of support for FastF1 v &lt; 3.1.0\n\n\n\nf1dataR 1.4.0\n\nFully deprecated round and fastest_only arguments\nAdded a function correct_track_ratio() to ensure plotted tracks have proper x & y ratios (#89, #179)\n\nUpdated plot_fastest() to use correct_track_ratio()\n\nAdded a function to help switch between cache choices (#170, #171)\n\nEnsured cache option had default (\"memory\") (#181, #183)\n\nSimplified Python package fastf1 installation (#187).\n\nVirtualenv and Conda environment management is up to the user now\n\n\n\n\nf1dataR 1.3.0\n\nUpdated documentation per requirements after CRAN review\nChanged caching behavior per requirements after CRAN review. If you previously had set a cache directory options(\"f1dataR.cache\" = [dir]) there will be no change. If you had previously not specified a cache directory, the package used to use the result of getwd(), so you can force that directory. New users can specify a default file cache location by setting options(\"f1dataR.cache\" = \"filesystem\") or specify any other (existing) directory by setting the option.\n\nCache will otherwise use memory as a default until the end of the R session or for 24h (whichever comes first). Caching can be turned off by setting the option to “off”\n\n\nf1dataR 1.2.1\n\nAdded additional output column to load_schedule() to show Sprint Race date.\n\n\n\nf1dataR 1.2.0\n\nAdded a helper function for setting up fastf1 connection.\nImproved testing coverage\nCode style and format cleanups\n\n\n\nf1dataR 1.1.0\n\nUpdated load_driver_telemetry to use laps parameter, allowing for a choice of ‘fastest’, ‘all’, or a numbered lap. Note a numbered lap requires fastf1 version 3.0 or greater (#78)\n\n\n\nf1dataR 1.0.1\n\nAdded examples to documentation (#95)\n\n\n\nf1dataR 1.0.0\n\nAdded a NEWS.md file to track changes to the package."
  },
  {
    "objectID": "f1dataR/vignettes/introduction.html",
    "href": "f1dataR/vignettes/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "f1dataR serves as a tool to get neatly organized Formula 1 data into your R environment. Here we will go over the basic functions to understand how the package works.\nThe most sought-after aspect of F1 data is telemetry data. Let’s get Leclerc’s fastest lap from the first race of 2022:\nlibrary(f1dataR)\n\nload_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\n#&gt; # A tibble: 697 × 19\n#&gt;    date                session_time  time   rpm speed n_gear throttle brake   drs source       \n#&gt;    &lt;dttm&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;        \n#&gt;  1 2022-03-19 15:58:18        4397. 0     10514   292      7      100 FALSE    12 interpolation\n#&gt;  2 2022-03-19 15:58:18        4397. 0.084 10502   293      7      100 FALSE    12 pos          \n#&gt;  3 2022-03-19 15:58:18        4398. 0.152 10478   294      8      100 FALSE    12 car          \n#&gt;  4 2022-03-19 15:58:18        4398. 0.384 10519   295      8      100 FALSE    12 pos          \n#&gt;  5 2022-03-19 15:58:18        4398. 0.392 10560   296      8      100 FALSE    12 car          \n#&gt;  6 2022-03-19 15:58:19        4398. 0.784 10628   297      8      100 FALSE    12 pos          \n#&gt;  7 2022-03-19 15:58:19        4398. 0.792 10696   299      8      100 FALSE    12 car          \n#&gt;  8 2022-03-19 15:58:19        4398. 0.952 10696   300      8      100 FALSE    12 car          \n#&gt;  9 2022-03-19 15:58:19        4398. 1.02  10734   301      8      100 FALSE    12 pos          \n#&gt; 10 2022-03-19 15:58:19        4399. 1.32  10773   302      8      100 FALSE    12 pos          \n#&gt; # ℹ 687 more rows\n#&gt; # ℹ 9 more variables: relative_distance &lt;dbl&gt;, status &lt;chr&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;, z &lt;dbl&gt;,\n#&gt; #   distance &lt;dbl&gt;, driver_ahead &lt;chr&gt;, distance_to_driver_ahead &lt;dbl&gt;, driver_code &lt;chr&gt;\nNow let’s use ggplot2 to visualize some of the data we have\nlibrary(dplyr)\nlibrary(ggplot2)\n\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\") %&gt;%\n  head(300)\n\nggplot(lec, aes(distance, throttle)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nPlot of lap distance vs throttle percentage for Leclerc at the 2022 Bahrain Grand Prix Qualifying session (specifically his fastest lap)\n\n\nWhat if we get more drivers involved. Let’s also get the Qualifying data from Hamilton and Pérez\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\") %&gt;%\n  head(300)\n\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\") %&gt;%\n  head(300)\n\ndata &lt;- bind_rows(lec, ham, per)\n\nggplot(data, aes(distance, throttle, color = driver_code)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nThrottle percent by distance for Leclerc, Hamilton and Perez from 2022 Bahrain Grand Prix Qualifying session"
  },
  {
    "objectID": "f1dataR/vignettes/introduction.html#basics",
    "href": "f1dataR/vignettes/introduction.html#basics",
    "title": "Introduction",
    "section": "",
    "text": "f1dataR serves as a tool to get neatly organized Formula 1 data into your R environment. Here we will go over the basic functions to understand how the package works.\nThe most sought-after aspect of F1 data is telemetry data. Let’s get Leclerc’s fastest lap from the first race of 2022:\nlibrary(f1dataR)\n\nload_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\n#&gt; # A tibble: 697 × 19\n#&gt;    date                session_time  time   rpm speed n_gear throttle brake   drs source       \n#&gt;    &lt;dttm&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;        \n#&gt;  1 2022-03-19 15:58:18        4397. 0     10514   292      7      100 FALSE    12 interpolation\n#&gt;  2 2022-03-19 15:58:18        4397. 0.084 10502   293      7      100 FALSE    12 pos          \n#&gt;  3 2022-03-19 15:58:18        4398. 0.152 10478   294      8      100 FALSE    12 car          \n#&gt;  4 2022-03-19 15:58:18        4398. 0.384 10519   295      8      100 FALSE    12 pos          \n#&gt;  5 2022-03-19 15:58:18        4398. 0.392 10560   296      8      100 FALSE    12 car          \n#&gt;  6 2022-03-19 15:58:19        4398. 0.784 10628   297      8      100 FALSE    12 pos          \n#&gt;  7 2022-03-19 15:58:19        4398. 0.792 10696   299      8      100 FALSE    12 car          \n#&gt;  8 2022-03-19 15:58:19        4398. 0.952 10696   300      8      100 FALSE    12 car          \n#&gt;  9 2022-03-19 15:58:19        4398. 1.02  10734   301      8      100 FALSE    12 pos          \n#&gt; 10 2022-03-19 15:58:19        4399. 1.32  10773   302      8      100 FALSE    12 pos          \n#&gt; # ℹ 687 more rows\n#&gt; # ℹ 9 more variables: relative_distance &lt;dbl&gt;, status &lt;chr&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;, z &lt;dbl&gt;,\n#&gt; #   distance &lt;dbl&gt;, driver_ahead &lt;chr&gt;, distance_to_driver_ahead &lt;dbl&gt;, driver_code &lt;chr&gt;\nNow let’s use ggplot2 to visualize some of the data we have\nlibrary(dplyr)\nlibrary(ggplot2)\n\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\") %&gt;%\n  head(300)\n\nggplot(lec, aes(distance, throttle)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nPlot of lap distance vs throttle percentage for Leclerc at the 2022 Bahrain Grand Prix Qualifying session (specifically his fastest lap)\n\n\nWhat if we get more drivers involved. Let’s also get the Qualifying data from Hamilton and Pérez\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\") %&gt;%\n  head(300)\n\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\") %&gt;%\n  head(300)\n\ndata &lt;- bind_rows(lec, ham, per)\n\nggplot(data, aes(distance, throttle, color = driver_code)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nThrottle percent by distance for Leclerc, Hamilton and Perez from 2022 Bahrain Grand Prix Qualifying session"
  },
  {
    "objectID": "f1dataR/vignettes/introduction.html#integrated-plotting",
    "href": "f1dataR/vignettes/introduction.html#integrated-plotting",
    "title": "Introduction",
    "section": "Integrated plotting",
    "text": "Integrated plotting\nThere are a couple of functions in the package that help with plotting. The first one is theme_dark_f1() that simply applies a theme similar to the official F1 graphics. We can apply it to our previous data.\nggplot(data, aes(distance, speed, color = driver_code)) +\n  geom_line() +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(\n    axis.title = element_text(),\n    axis.line = element_line(color = \"white\"),\n  ) +\n  labs(\n    title = \"Speed Comparison for Bahrain 2022\"\n  )\n\n\n\nThrottle percent by distance for the three drivers, with f1dataR theme applied\n\n\nAnother built-in function is plot_fastest() that can plot the speed or gear changes throughout the fastest lap for a driver/race.\nplot_fastest(2022, 1, \"R\", \"PER\")\n#&gt; ℹ If the session has not been loaded yet, this could take a minute\n\n\n\nFastest lap for Perez from the 2022 Bahrain Grand Prix, showing gear used at each point in the lap"
  },
  {
    "objectID": "f1dataR/vignettes/introduction.html#combining-several-functions",
    "href": "f1dataR/vignettes/introduction.html#combining-several-functions",
    "title": "Introduction",
    "section": "Combining several functions",
    "text": "Combining several functions\nNow let’s look at a more complete analysis. We want to visualize how lap time change over time (tyre age) for Pérez with every compound used in the Spanish GP.\nlaps &lt;- load_session_laps(2023, \"Spain\") %&gt;%\n  filter(driver == \"PER\") %&gt;%\n  group_by(compound) %&gt;%\n  # Remove in and out laps\n  filter(tyre_life != 1 & tyre_life != max(tyre_life)) %&gt;%\n  ungroup()\n\nggplot(laps, aes(tyre_life, lap_time, color = compound)) +\n  geom_line() +\n  geom_point() +\n  theme_dark_f1(axis_marks = TRUE) +\n  labs(\n    color = \"Tyre Compound\",\n    y = \"Lap Time (Seconds)\",\n    x = \"Tyre Life (Laps)\"\n  ) +\n  scale_color_manual(\n    values = c(\"white\", \"yellow\", \"red\")\n  ) +\n  scale_y_continuous(breaks = seq(75, 85, 1)) +\n  scale_x_continuous(breaks = seq(2, 26, 4))\n\n\n\nAverage laptime per tyre type and age at Spanish Grand Prix 2023\n\n\nNow let’s visualize the portion of the track where Verstappen had the throttle 100% open in the 2023 Canadian GP. Note that we’ll pass the plot through the helper function correct_track_ratio() to ensure the plotted track has correct dimensions (and a few other tweaks for pretty plotting). Alternatively, you can call ggplot2::coord_fixed() while building track plots to ensure the x & y ratios are equal.\nver_can &lt;- load_driver_telemetry(\n  season = 2023,\n  round = \"Canada\",\n  driver = \"VER\",\n  laps = \"fastest\"\n) %&gt;%\n  mutate(open_throttle = ifelse(throttle == 100, \"Yes\", \"No\"))\n\nthrottle_plot &lt;- ggplot(ver_can, aes(x, y, color = as.factor(open_throttle), group = NA)) +\n  geom_path(linewidth = 4, lineend = \"round\") +\n  scale_color_manual(values = c(\"white\", \"red\")) +\n  theme_dark_f1() +\n  labs(\n    title = \"Verstappen Flat Out\",\n    subtitle = \"Canada 2023 | Fastest Lap\",\n    color = \"Throttle 100%\"\n  )\n\ncorrect_track_ratio(throttle_plot)\n\n\n\nVerstappen fastest lab in the Canadian Grand Prix 2023, showing full throttle sections\n\n\nFor a simpler visualization let’s look at the average time it took each team to pit in round 4 of 2023. For this we will have to load the pit data, the results data (to extract driver + team combos), and read the constructor data to get the colors for our plot. Note the time is the difference from pit entry to exit, not stopped time.\npit_data &lt;- load_pitstops(2023, 4)\n\ndriver_team &lt;- load_results(2023, 4) %&gt;%\n  select(driver_id, constructor_id)\n\npit_constructor &lt;- pit_data %&gt;%\n  left_join(driver_team, by = \"driver_id\") %&gt;%\n  group_by(constructor_id) %&gt;%\n  summarise(pit_time = mean(as.numeric(duration)))\n\npit_constructor$constructor_color &lt;- sapply(pit_constructor$constructor_id, get_team_color, season = 2023, round = 4, USE.NAMES = FALSE)\n\npit_constructor$team_name &lt;- sapply(pit_constructor$constructor_id, get_team_name, season = 2023, short = TRUE, USE.NAMES = FALSE)\n\nggplot(pit_constructor, aes(x = team_name, y = pit_time, fill = team_name)) +\n  geom_bar(stat = \"identity\", fill = pit_constructor$constructor_color) +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(\n    legend.position = \"none\"\n  ) +\n  labs(\n    x = \"Constructor\",\n    y = \"Average Pit Time (seconds)\"\n  ) +\n  ggtitle(\"Average time in pit lane for each team\", subtitle = \"Azerbaijan Grand Prix 2023\")\n\n\n\nAverage time in pits for each team at the 2023 Azerbaijan Grand Prix"
  },
  {
    "objectID": "f1dataR/vignettes/alonso-penalty-2024.html",
    "href": "f1dataR/vignettes/alonso-penalty-2024.html",
    "title": "Alonso’s Penalty in the Australian GP 2024",
    "section": "",
    "text": "In the closing laps of the 2024 Australian Grand Prix, the lone remaining Mercedes of George Russell was in a showdown with Aston Martin’s Fernando Alonso. On the penultimate lap, Russell crashed out at turn 6-7, coming to a stop at an awkward angle and askew across the track. Following the race, both drivers were called to the Stewards, who discussed the incident with both drivers and reviewed data and video. They handed Alonso a 20 second penalty for causing the crash, despite there not having been any contact between the two drivers. A large portion of the decision rested on the telemetry from the drivers’ cars. While the Stewards, FIA and teams have much more detailed data than we do, we can repeat their analysis using R, f1dataR and the Python FastF1 package.\n\nAccessing the Data\nWe’ll start by loading the f1dataR package, and preparing the Python virtual environment (including installing FastF1). This happens automatically with a call to setup_fastf1(), see the setup_fastf1 vignette for more information.\nlibrary(f1dataR)\nsetup_fastf1()\nSince the crash occurred on lap 57, we’ll download telemetry for Alonso for the five previous laps to compare what Alonso did on the fateful lap compared to those before. We’ll also load Russell’s telemetry from those same laps to see how he reacts before the crash. Note we use some dplyr for data manipulation.\nalo_telem &lt;- dplyr::bind_rows(lapply(c(52:57), function(l) load_driver_telemetry(season = 2024, round = \"Australia\", session = \"R\", driver = \"ALO\", laps = l) %&gt;% dplyr::mutate(lap = l)))\nrus_telem &lt;- dplyr::bind_rows(lapply(c(52:57), function(l) load_driver_telemetry(season = 2024, round = \"Australia\", session = \"R\", driver = \"RUS\", laps = l) %&gt;% dplyr::mutate(lap = l)))\nA few manipulations now will make later plotting easier:\nalo_telem$lap &lt;- as.factor(alo_telem$lap)\nalo_telem$brake &lt;- as.integer(alo_telem$brake)\nrus_telem$lap &lt;- as.factor(rus_telem$lap)\nrus_telem$brake &lt;- as.integer(rus_telem$brake)\n\n\nTelemetry Review\nAlonso stated he had some challenges with his car (specifically the ERS deployment system, according to an interview he did with Sky Sports as reported on f1.com). But if we look at the telemetry from Alonso comparing lap 57 to the previous, we see the following (focusing on the T6-7 area from 1500 to 2000 m into the lap):\nggplot2::ggplot(alo_telem, ggplot2::aes(x = distance, y = throttle, color = lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::ggtitle(\"Alonso Throttle % by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(\"Throttle %\") +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 3489 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nThrottle Percent by Distance, per lap, for Fernando Alonso at the 2024 Australian GP\n\n\nIn this plot we can see that he let off the throttle about 180 m before any other lap, and had to put some throttle back on before the normal braking point. This doesn’t line up with someone suffering from ERS deployment, but instead an intentional effort to drive the car differently then in the previous laps.\nSimilarly, we can look at braking (on/off), selected gear, and speed traces to see all the changes in driving style for that lap:\nlong_telem_alo &lt;- alo_telem %&gt;%\n  dplyr::select(c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"lap\", \"distance\")) %&gt;%\n  tidyr::pivot_longer(\n    cols = c(\"speed\", \"n_gear\", \"throttle\", \"brake\"),\n    names_to = \"param\",\n    values_to = \"value\"\n  ) %&gt;%\n  dplyr::mutate(param = dplyr::case_match(\n    param,\n    \"speed\" ~ \"Speed (kph)\",\n    \"n_gear\" ~ \"Gear\",\n    \"throttle\" ~ \"Throttle %\",\n    \"brake\" ~ \"Brake (on/off)\"\n  )) %&gt;%\n  dplyr::rename(\"Lap\" = \"lap\") %&gt;%\n  dplyr::mutate(param = factor(param, c(\"Speed (kph)\", \"Throttle %\", \"Gear\", \"Brake (on/off)\")))\n\nggplot2::ggplot(long_telem_alo, ggplot2::aes(x = distance, y = value, color = Lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::facet_grid(rows = ggplot2::vars(param), scales = \"free\") +\n  ggplot2::ggtitle(\"Alonso Telemetry by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(NULL) +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 13956 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nTelemetry (Speed, Throttle, Gear, Brake) by Distance, per lap, for Fernando Alonso at the 2024 Australian GP\n\n\nAlonso, at the Stewards visit, claimed intent to drive a different line at T6 (Stewards document, reported on f1.com). This aligns better with the telemetry, there are multiple actions going on (reduction of throttle, application of brake, downshift) that indicate that the reduction of speed was intentional (and poorly timed, he had to accelerate a bit to get into the corner).\n\n\nEffect on Russell\nRussell, of course, was tailing Alonso, and the telemetry provides a (calculated/interpolated) distance behind the driver in front. We can observe this (with his other telemetry lines too).\nlong_telem_rus &lt;- rus_telem %&gt;%\n  dplyr::select(c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"lap\", \"distance\", \"distance_to_driver_ahead\")) %&gt;%\n  tidyr::pivot_longer(\n    cols = c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"distance_to_driver_ahead\"),\n    names_to = \"param\",\n    values_to = \"value\"\n  ) %&gt;%\n  dplyr::filter(!(param == \"distance_to_driver_ahead\" & value &gt; 50)) %&gt;%\n  dplyr::mutate(param = dplyr::case_match(\n    param,\n    \"speed\" ~ \"Speed (kph)\",\n    \"n_gear\" ~ \"Gear\",\n    \"throttle\" ~ \"Throttle %\",\n    \"brake\" ~ \"Brake (on/off)\",\n    \"distance_to_driver_ahead\" ~ \"Gap (m)\"\n  )) %&gt;%\n  dplyr::rename(\"Lap\" = \"lap\") %&gt;%\n  dplyr::mutate(param = factor(param, c(\"Gap (m)\", \"Speed (kph)\", \"Throttle %\", \"Gear\", \"Brake (on/off)\")))\n\nggplot2::ggplot(long_telem_rus, ggplot2::aes(x = distance, y = value, color = Lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::facet_grid(rows = ggplot2::vars(param), scales = \"free\") +\n  ggplot2::ggtitle(\"Russell Telemetry by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(NULL) +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 13834 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nTelemetry (Speed, Throttle, Gear, Brake, and Gap to Alonso) by Distance, per lap, for George Russell at the 2024 Australian GP\n\n\nYou can see a sudden and dramatic decrease in the distance between Alonso and Russell in lap 57 (starting around 1575 m). Russell reacted by applying brake earlier than other laps (by a few meters) and was off the throttle earlier than most laps. It was 1.271 s between when Alonso and Russel let off the throttle.\nRussell didn’t expect Alonso to do this move there. The Stewards’ decision rested on the lack of predictability of Alonso. There’s typically only one line through turns 6 & 7, compromising your speed anywhere leaves you vulnerable down the road. Our telemetry access doesn’t provide enough detail to prove that the decrease in distance between the cars caused the problem (all we can see is they got to within 18.6 m, but the replays made it look much closer). Would this have been a penalty if Russell hadn’t crashed? Should Russell have reacted quicker?\n\n\nLimitations\nThere’s key limitations in this data - the most significant being that it’s at a resolution of only about 4 Hertz. The nuances of car gap, reaction times, etc. are all lost in the coarse data we have access to. The FIA, Teams, and Stewards have a much higher resolution available, with many additional data sources too. They also have the testimony of the teams and drivers to consider in their decision, and lots of video sources.\nFor more information on this, read the Stewards’ documents,"
  },
  {
    "objectID": "posts/f1-norris-vs-teammate/index.html",
    "href": "posts/f1-norris-vs-teammate/index.html",
    "title": "SEC 2024 : Alabama vs Georgia",
    "section": "",
    "text": "In the highly competitive Southeastern Conference, rivalry between Alabama and Georgia runs deep. With constant competition between the two in recent years, there have been many conversations about which team is better. Alabama currently holds the record for most conference wins with 30. Georgia has 14, including 2024. Though the Bulldogs won the conference title, they were ranked second with a 6-2 conference record. Alabama finished the season ranked fourth with a 5-3 record. Just how close were statistically were the two teams?\nSurprise (or not) there wasn’t a huge gap.\n\n\nCode\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(ggrepel)\nlibrary(ggalt)\n\n\nRegistered S3 methods overwritten by 'ggalt':\n  method                  from   \n  grid.draw.absoluteGrob  ggplot2\n  grobHeight.absoluteGrob ggplot2\n  grobWidth.absoluteGrob  ggplot2\n  grobX.absoluteGrob      ggplot2\n  grobY.absoluteGrob      ggplot2\n\n\nCode\nlibrary(ggtext)\nlibrary(waffle)\nlibrary(patchwork)\n\n\n\n\nCode\nlogs24 &lt;- read_csv(\"https://mattwaite.github.io/sportsdatafiles/footballlogs24.csv\")\n\n\n\n\nCode\nsec &lt;- logs24 |&gt; \n  filter(Conference == \"Southeastern Conference\")\n\n\nLet’s begin by taking a look at total interceptions and fumbles throughout the 2024 season. Georgia caught 13 interceptions, opposed to Alabama’s 11. Interestingly, three of Alabama’s interceptions were caught during the Alabama v Georgia game.\nOn the flip side, Alabama landed in the top five teams with the most fumbles. Not a place you want to be.\n\n\nCode\nalabama &lt;- sec |&gt;\n  filter(\n    Team == \"Alabama\"\n  )\n\ngeorgia &lt;- sec |&gt;\n  filter(\n    Team == \"Georgia\"\n  )\n\nbar1 &lt;- ggplot() + \n  geom_bar(data=sec, aes(x=reorder(Team, Interceptions), weight=Interceptions), fill=\"light grey\") +\n  geom_bar(data=alabama, aes(x=reorder(Team, Interceptions), weight=Interceptions), fill=\"#9E1B32\") +   geom_bar(data=georgia, aes(x=reorder(Team, Interceptions), weight=Interceptions), fill=\"#004E60\") +\n  coord_flip() +\n  labs(\n    x=\"Teams\", \n    y=\"Interceptions\", \n    title=\"When it comes to interceptions...\", \n    subtitle=\"Georgia beats out Alabama, and most of the SEC.\", \n    caption=\"Source: footballlogs24.csv | By Aspen Reynolds\"\n    ) +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 20, face = \"bold\")\n    )\n\n\n\n\nCode\nalabama &lt;- sec |&gt;\n  filter(\n    Team == \"Alabama\"\n  )\n\ngeorgia &lt;- sec |&gt;\n  filter(\n    Team == \"Georgia\"\n  )\n\nbar2 &lt;- ggplot() + \n  geom_bar(data=sec, aes(x=reorder(Team, Fumbles), weight=Fumbles), fill=\"lightgrey\") +\n  geom_bar(data=alabama, aes(x=reorder(Team, Fumbles), weight=Fumbles), fill=\"#9E1B32\") +   geom_bar(data=georgia, aes(x=reorder(Team, Fumbles), weight=Fumbles), fill=\"#004E60\") +\n  coord_flip() +\n  labs(\n    x=\"Teams\", \n    y=\"Fumbles\", \n    title=\"Fumbles on the other hand...\", \n    subtitle=\"Alabama had several more than Georgia throughout the season.\", \n    caption=\"Source: footballlogs24.csv | By Aspen Reynolds\"\n    ) +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 20, face = \"bold\")\n    ) \n\n\n\n\nCode\nbar1 / bar2\n\n\n\n\n\n\n\n\n\nNext, let’s look at the average rushing yards and passing percentage. Alabama was strong in both categories, specifically in their average rushing yards. They were steadily improving and peaked in the middle of the season. Georgia never fell far below the average, but never went much above it either.\nLooking at Georgia’s passing accuracy can clarify why they don’t run the ball much. Staying steadily near or above the SEC average, they at one point were catching over 75% of their throws. Alabama started with an even higher percentage, but it fell closer to the average throughout the season.\n\n\nCode\nsec &lt;- logs24 |&gt; \n  filter(Conference == \"Southeastern Conference\")\naverage &lt;- sec |&gt; group_by(Date) |&gt; summarise(meanrush=mean(RushingAvg))\n\nline1 &lt;- ggplot() + \n  geom_line(data=sec, aes(x=Date, y=RushingAvg, group=Team), color=\"lightgrey\") +\n  geom_line(data=alabama, aes(x=Date, y=RushingAvg), color=\"#9E1B32\") +\n  geom_line(data=georgia, aes(x=Date, y=RushingAvg), color=\"#004E60\") +\n  geom_line(data=average, aes(x=Date, y=meanrush), color=\"hotpink\") + \n  annotate(\"text\", x=(as.Date(\"2024-10-26\")), y=7.8, label=\"Alabama\") +\n  annotate(\"text\", x=(as.Date(\"2024-11-09\")), y=1.5, label=\"Georgia\") +\n  annotate(\"text\", x=(as.Date(\"2024-12-16\")), y=5.5, label=\"SEC Average\") +\n  scale_y_continuous(limits = c(0, 10)) +\n  labs(\n    x=\"Date\", \n    y=\"Average Rushing Yards\", \n    title=\"Alabama rises above average periodically, Georgia remains consistent\", \n    subtitle=\"The Crimson Tide rose above the SEC average significantly in the middle of the season.\", \n    caption=\"Source: footballlogs24.csv | By Aspen Reynolds\"\n    ) +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 14, face = \"bold\")\n    ) \n\n\n\n\nCode\nsec &lt;- logs24 |&gt; \n  filter(Conference == \"Southeastern Conference\")\naverage &lt;- sec |&gt; group_by(Date) |&gt; summarise(meanpass=mean(PassingPct))\n\nline2 &lt;- ggplot() + \n  geom_line(data=sec, aes(x=Date, y=PassingPct, group=Team), color=\"lightgrey\") +\n  geom_line(data=alabama, aes(x=Date, y=PassingPct), color=\"#9E1B32\") +\n  geom_line(data=georgia, aes(x=Date, y=PassingPct), color=\"#004E60\") +\n  geom_line(data=average, aes(x=Date, y=meanpass), color=\"hotpink\") + \n  annotate(\"text\", x=(as.Date(\"2024-11-23\")), y=35, label=\"Alabama\") +\n  annotate(\"text\", x=(as.Date(\"2024-09-28\")), y=50, label=\"Georgia\") +\n  annotate(\"text\", x=(as.Date(\"2024-11-09\")), y=55, label=\"SEC Average\") +\n  scale_y_continuous(limits = c(0, 100)) +\n  labs(\n    x=\"Date\", \n    y=\"Pass Completion Percentage\", \n    title=\"Alabama & Georgia v The SEC\", \n    subtitle=\"Though both teams had highs and lows, they remained fairly close to the SEC average.\", \n    caption=\"Source: footballlogs24.csv | By Aspen Reynolds\"\n    ) +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 20, face = \"bold\")\n    ) \n\n\n\n\nCode\nline1 / line2 \n\n\n\n\n\n\n\n\n\n\n\nCode\nwinlosssec &lt;- sec |&gt; \n  mutate(\n    wins = case_when(\n      grepl(\"W\", Outcome) ~ 1, \n      grepl(\"L\", Outcome) ~ 0)\n)\n\n\n\n\nCode\nypp &lt;- winlosssec |&gt; \n  group_by(Team, Conference) |&gt; \n  summarise(\n    TotalPlays = sum(OffensivePlays), \n    TotalYards = sum(OffensiveYards), \n    DefensivePlays = sum(DefPlays), \n    DefensiveYards = sum(DefYards), \n    TotalWins = sum(wins)) |&gt; \n  mutate(\n    OffensiveYPP = TotalYards/TotalPlays, \n    DefensiveYPP = DefensiveYards/DefensivePlays)\n\n\n\n\nCode\nypp |&gt; \n  ungroup() |&gt; \n  summarise(\n    offense = mean(OffensiveYPP), \n    defense = mean(DefensiveYPP)\n    )\n\n\n# A tibble: 1 × 2\n  offense defense\n    &lt;dbl&gt;   &lt;dbl&gt;\n1    6.01    5.22\n\n\nWhen it comes to comparing them in average yards per play, Alabama once again rose above Georgia. Throughout the season, the Crimson Tide had more offensive yards gained compared to the Bulldogs, while also giving away less yards defensively.\n\n\nCode\nsec &lt;- ypp |&gt; filter(Conference == \"Southeastern Conference\")\nalaypp &lt;- ypp |&gt; filter(Team == \"Alabama\")\ngeoypp &lt;- ypp |&gt; filter(Team == \"Georgia\")\n\nggplot() + \n  geom_point(\n    data=ypp, \n    aes(x=OffensiveYPP, y=DefensiveYPP, size=TotalWins), \n    color=\"grey\", \n    alpha=.3) + \n  geom_point(\n    data=alaypp, \n    aes(x=OffensiveYPP, y=DefensiveYPP, size=TotalWins), \n    color=\"#9E1B32\") +\n  geom_point(\n    data=geoypp, \n    aes(x=OffensiveYPP, y=DefensiveYPP, size=TotalWins), \n    color=\"#004E60\") + \n  geom_vline(xintercept = 6.014997) + \n  geom_hline(yintercept = 5.217725) +\n  geom_text_repel(\n    data=sec, \n    aes(x=OffensiveYPP, y=DefensiveYPP, label=Team)) +\n  labs(\n    x=\"Offensive Yards Per Play\", \n    y=\"Defensive Yards Per Play\", \n    title=\"Alabama outshines Georgia, and most of the SEC\", \n    subtitle=\"On a per play basis, the Crimson Tide ranked higher than the majority of the conference.\",\n    caption=\"Source: footballlogs24.csv | By Aspen Reynolds\") +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 20, face = \"bold\")\n    ) \n\n\n\n\n\n\n\n\n\nWe’ve seen how both teams compare throughout the season, but what about when they played each other? One of the best games of the season, Alabama won 41-34 after dominating the first half. Georgia then had a massive comeback scoring 19 points in the 4th quarter. With each team being dominant in a different half, their total yards ended fairly close. With Alabama having only 32 more yards, the game on paper looks a lot more even than it was.\nAlabama\n\n\nCode\na &lt;- c(\"Rushing\"=177, \"Passing\"=374)\ng &lt;- c(\"Rushing\"=80, \"Passing\"=439)\n\n\n\n\nCode\ntotal &lt;- c(\"Alabama\"=551, \"Georgia\"=519)\n\nwaffle(\n        total/2, \n        rows = 20, \n        colors = c(\"#9E1B32\", \"#004E60\")) +\n   labs(\n       x=\"1 square = 2 yards\",\n       title=\"Alabama and Georgia's almost equal yards\",\n       subtitle=\"With how close the yards are, Georgia's comeback is impressive.\", \n    caption=\"Source: https://www.espn.com/college-football/boxscore/_/gameId/401628374 | By Aspen Reynolds\") +\n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 20, face = \"bold\")\n    ) \n\n\n\n\n\n\n\n\n\nLooking at the total yards shows that while Alabama had more, it was nearly equal with them having 551 yards and Georgia with 519. This highlights Georgia’s ability to make strong offensive plays and noted how Alabama had things to work on with their defense.\nWhen we break it down and look at each teams offense, both heavily favored passing rather than running the ball, Georgia specifically. Alabama ran the ball for more than double the yards, which likely helped them secure their win.\n\n\nCode\ng2 &lt;- c(\"Rushing\"=80, \"Passing\"=439, 32)\n\niron(\n waffle(a/2, \n        rows = 10, \n        colors = c(\"#9E1B32\", \"#828a8f\")) +\n        labs(\n          x=\"Alabama\",\n          title=\"Alabama vs Georgia's Offense : By the numbers\",\n          subtitle= \"The Bulldogs preferred passing, with 97 less rushing yards than the Crimson Tide.\") +\n        theme(\n          plot.title = element_text(size = 16, face = \"bold\"),\n          axis.title = element_text(size = 10),\n          axis.title.y = element_blank()\n    ),\n waffle(g2/2, \n        rows = 10, \n        colors = c(\"#004E60\", \"#9EA2A2\", \"white\")) +\n        labs(\n          x = \"Georgia\\n1 square = 2 yards\",\n          caption=\"Source: https://www.espn.com/college-football/boxscore/_/gameId/401628374 | By Aspen Reynolds\"\n          ) +\n  theme_minimal()\n    ) \n\n\n\n\n\n\n\n\n\nOverall, though Alabama didn’t play or win in the conference championship, they still had an above average season. More times than not they outplayed Georgia, including when playing directly against them. There is no doubt that the rivalry will continue to thrive as well as their football programs, and we’ll see who takes the next conference title."
  },
  {
    "objectID": "f1dataR/vignettes/setup_fastf1.html",
    "href": "f1dataR/vignettes/setup_fastf1.html",
    "title": "Setup FastF1 Connection",
    "section": "",
    "text": "This vignette briefly describes setting up the f1dataR package to work properly with with the Python package FastF1. This guide may help resolve some issues that might arise when you get the following warning or error messages:\n\nEnsure fastf1 python package is installed. Please run this to install the most recent version: setup_fastf1()\nError in if (get_fastf1_version() &lt; '3.1') { : missing value where TRUE/FALSE needed\n\nIf these happen to you (particularly if you’re a new user of f1dataR) read on!"
  },
  {
    "objectID": "f1dataR/vignettes/setup_fastf1.html#accept-all-defaults",
    "href": "f1dataR/vignettes/setup_fastf1.html#accept-all-defaults",
    "title": "Setup FastF1 Connection",
    "section": "Accept all defaults",
    "text": "Accept all defaults\nTo use all of the defaults and set up the reticulate package, you can use the below helper function.\nsetup_fastf1()\nThis will create a virtual environment using your system’s default Python version, and install fastf1 in that python environment. It will also tell reticulate to use that environment instead of just running in your main system. Many resources exist online to explain python environments in more detail."
  },
  {
    "objectID": "f1dataR/vignettes/plotting-turn-info.html",
    "href": "f1dataR/vignettes/plotting-turn-info.html",
    "title": "Plotting with FastF1 Circuit Information",
    "section": "",
    "text": "Introduction\nThis vignette provides a few demonstrations of the use of FastF1 circuit data in generating plots.\nWe’ll load all the required libraries for our data analysis:\nlibrary(f1dataR)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\nTelemetry Plotting\nAs in our Introduction vignette, we’ll start by working with telemetry data.\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\")\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\")\n\ntelem &lt;- bind_rows(lec, ham, per) %&gt;%\n  select(rpm, speed, n_gear, throttle, brake, drs, distance, time, driver_code) %&gt;%\n  mutate(drs = ifelse(drs == 12, 1, 0))\n\ndrivercolours &lt;- c(\n  \"LEC\" = get_driver_color(\"LEC\", 2022, 1),\n  \"HAM\" = get_driver_color(\"HAM\", 2022, 1),\n  \"PER\" = get_driver_color(\"PER\", 2022, 1)\n)\nTo demonstrate the addition of turn information, we’ll start by plotting the speed telemetry for the three drivers\ntelem_plot_speed &lt;- ggplot(telem, aes(x = distance, y = speed, color = driver_code)) +\n  geom_path() +\n  scale_color_manual(values = drivercolours) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2022 Bahrain Grand Prix Qualifying Telemetry\", subtitle = \"Speed vs Distance in lap\") +\n  xlab(\"Distance (m)\") +\n  ylab(\"Speed\") +\n  labs(color = \"Driver\")\n\ntelem_plot_speed\n\n\n\nSpeed by Distance for Leclerc, Hamilton and Perez after qualifying best laps\n\n\nNow, to add the corner numbers to a plot like this, we’ll have to retrieve those from FastF1.\nbahrain_circuit &lt;- load_circuit_details(2022, 1)\nbahrain_corners &lt;- bahrain_circuit$corners\n\nspeedmax &lt;- max(telem$speed, na.rm = TRUE)\nspeedmin &lt;- min(telem$speed, na.rm = TRUE)\nNow we can add these indicators to the previous plot:\ntelem_plot_speed +\n  geom_vline(xintercept = bahrain_corners$distance, linetype = \"longdash\", color = \"#646464\") +\n  geom_label(data = bahrain_corners, aes(\n    label = paste0(number, letter),\n    y = speedmin - 10,\n    x = distance,\n    color = \"#9A9A9A\"\n  ), show.legend = FALSE)\n\n\n\nSpeed by distance plot as above, but with turn numbres added\n\n\nOf course, these labels overlap slightly for turns close together (1-3, 5-7, 9-10, 14-15). Other packages such as ggrepel can handle these situations better, but are not the point of this demonstration.\n\n\nPlotting Turn Number On Track\nSimilar to the plotting of turn numbers on telemetry, we can add these annotations to the typical track plot.\nWe’ll work with 2022 Silverstone (British Grand Prix) for this plot. Lets’ start by getting the data:\nver &lt;- load_driver_telemetry(season = 2022, round = \"Silverstone\", session = \"Q\", driver = \"VER\", laps = \"fastest\")\nsilverstone_circuit &lt;- load_circuit_details(season = 2022, round = \"Silverstone\")\nNow we’ll plot it. Look to the bottom of the code to see the addition of labels.\ngear_plot &lt;- ggplot(ver, aes(x, y, color = as.factor(n_gear), group = NA)) +\n  geom_path(linewidth = 4, lineend = \"round\") +\n  ggplot2::scale_color_manual(\n    name = \"Gear\",\n    values = c(\n      \"1\" = \"#BC3C29\", \"2\" = \"#0072B5\", \"3\" = \"#E18727\", \"4\" = \"#20854E\",\n      \"5\" = \"#7876B1\", \"6\" = \"#6F99AD\", \"7\" = \"#FFDC91\", \"8\" = \"#EE4C97\"\n    ),\n    aesthetics = c(\"color\", \"fill\")\n  ) +\n  theme_dark_f1() +\n  labs(\n    title = \"British Grand Prix 2022\",\n    subtitle = \"Gear in use by Verstappen in Quali\",\n    color = \"Gear\"\n  )\nlabelled_gear_plot &lt;- gear_plot +\n  geom_label(data = silverstone_circuit$corners, aes(\n    label = paste0(number, letter),\n    y = y,\n    x = x,\n    color = \"#9A9A9A\"\n  ), show.legend = FALSE)\n\ncorrect_track_ratio(labelled_gear_plot)\n\n\n\nGear selected by Verstappen during his Silverstone fastest qualifying lap\n\n\nLike before, the plot has some issues with overlap. But this time, beyond using ggrepel, we have the data provided to move the labels in a ‘pretty’ way.\nThe data returned by get_circuit_data() includes an extra column (angle) that can be used to determine an adequate shift angle for the label. With that data, and some careful math, we can move the labels to where we want them.\nlabelx &lt;- function(x, angle, distance = 750) {\n  angle &lt;- angle * pi / 180\n  return(cos(angle) * distance + x)\n}\nlabely &lt;- function(y, angle, distance = 750) {\n  angle &lt;- angle * pi / 180\n  return(sin(angle) * distance + y)\n}\n\nsilverstone_circuit$corners$labx &lt;- labelx(silverstone_circuit$corners$x, silverstone_circuit$corners$angle)\nsilverstone_circuit$corners$laby &lt;- labely(silverstone_circuit$corners$y, silverstone_circuit$corners$angle)\nWith those new label x and y points calculated, we can re-plot the labels slightly offset from the track.\nlabelled_gear_plot2 &lt;- gear_plot +\n  geom_label(data = silverstone_circuit$corners, aes(\n    label = paste0(silverstone_circuit$corners$number, silverstone_circuit$corners$letter),\n    y = silverstone_circuit$corners$laby,\n    x = silverstone_circuit$corners$labx,\n    color = \"white\",\n  ), size = 3, label.padding = unit(0.15, \"lines\"), show.legend = FALSE)\n\ncorrect_track_ratio(labelled_gear_plot2)\n\n\n\nPlot showing gear in use by Vertappen around Silversone, with corner labels applied\n\n\nFurther exploration (including label repelling) is left to the reader."
  },
  {
    "objectID": "f1dataR/vignettes/jolpica-data-analysis.html",
    "href": "f1dataR/vignettes/jolpica-data-analysis.html",
    "title": "Jolpica Data Analysis",
    "section": "",
    "text": "This vignette provides a few demonstrations of possible data analysis projects using f1dataR and the data pulled from the Jolpica API. All of the data used comes from Jolpica and is not supplied by Formula 1. However, this data source is incredibly useful for accessing a host of data.\nThis package (and vignette) previously used the Ergast Motor Racing Database. Unfortunately, Ergast was shuttered in 2024. Jolpica was developed as a direct replacement.\nWe’ll load all the required libraries for our data analysis:\nlibrary(f1dataR)\nlibrary(dplyr)"
  },
  {
    "objectID": "f1dataR/vignettes/jolpica-data-analysis.html#grid-to-finish-position-correlation",
    "href": "f1dataR/vignettes/jolpica-data-analysis.html#grid-to-finish-position-correlation",
    "title": "Jolpica Data Analysis",
    "section": "Grid to Finish Position Correlation",
    "text": "Grid to Finish Position Correlation\nWe can look at the correlation between the starting (grid) position and the race finishing position. We’ll look at the Austrian Grand Prix from 2020 for this analysis, not because of any particular reason, but that it produced a well mixed field.\nlibrary(ggplot2)\n# Load the data\nresults &lt;- load_results(2020, 1) %&gt;%\n  mutate(\n    grid = as.numeric(grid),\n    position = as.numeric(position)\n  )\n\nggplot(results, aes(x = position, y = grid)) +\n  geom_point(color = \"white\") +\n  stat_smooth(method = \"lm\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2020 Austrian Grand Prix Grid - Finish Position\") +\n  xlab(\"Finish Position\") +\n  ylab(\"Grid Position\")\n\n\n\nA plot of grid position (y axis) vs race finishing position (x axis) for the 2020 Austrian Grand Prix\n\n\nOf course, this isn’t really an interesting plot for a single race. Naturally we expect that a better grid position yields a better finish position, but there’s so much variation in one race (including the effect of DNF) that it’s a very weak correlation. We can look at the whole season instead by downloading sequentially the list of results. We’ll filter the results to remove those who didn’t finish the race, and also those who didn’t start from the grid (i.e. those who started from Pit Lane, where grid = 0).\n# Load the data\nresults &lt;- data.frame()\nfor (i in seq_len(17)) {\n  Sys.sleep(1)\n  r &lt;- load_results(2022, i)\n  results &lt;- dplyr::bind_rows(results, r)\n}\n\nresults &lt;- results %&gt;%\n  mutate(\n    grid = as.numeric(grid),\n    position = as.numeric(position)\n  ) %&gt;%\n  filter(status %in% c(\"Finished\", \"+1 Lap\", \"+2 Laps\", \"+6 Laps\"), grid &gt; 0)\n\nggplot(results, aes(y = position, x = grid)) +\n  geom_point(color = \"white\", alpha = 0.2) +\n  stat_smooth(method = \"lm\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"2020 F1 Season Grid - Finish Position\") +\n  ylab(\"Finish Position\") +\n  xlab(\"Grid Position\")\n\n\n\nA plot of grid position (y axis) vs race finishing position (x axis) for all 2020 Grands Prix\n\n\nAs expected, this produces a much stronger signal confirming our earlier hypothesis."
  },
  {
    "objectID": "f1dataR/vignettes/jolpica-data-analysis.html#driver-points-progress",
    "href": "f1dataR/vignettes/jolpica-data-analysis.html#driver-points-progress",
    "title": "Jolpica Data Analysis",
    "section": "Driver Points Progress",
    "text": "Driver Points Progress\nJolpica contains the points for drivers’ or constructors’ championship races as of the end of every round in a season. We can pull a season’s worth of data and compare the driver pace throughout the season, looking at both position or total points accumulation. We’ll do that for 2021, which had good competition throughout the year for P1.\n# Load the data\npoints &lt;- data.frame()\nfor (rnd in seq_len(22)) {\n  p &lt;- load_standings(season = 2021, round = rnd) %&gt;%\n    mutate(round = rnd)\n  points &lt;- rbind(points, p)\n  Sys.sleep(1)\n}\n\npoints &lt;- points %&gt;%\n  mutate(\n    position = as.numeric(position),\n    points = as.numeric(points)\n  )\n\n# Plot the Results\nggplot(points, aes(x = round, y = position, color = driver_id)) +\n  geom_line() +\n  geom_point(size = 1) +\n  ggtitle(\"Driver Position\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Position\") +\n  scale_y_reverse(breaks = seq_along(length(unique(points$position)))) +\n  theme_dark_f1(axis_marks = TRUE)\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_line()`).\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\nDriver ranking after each Grand Prix of the 2021 season\n\n\nWhat may be more interesting is the total accumulation of points. For that we can change up the plot just a little bit.\n# Plot the Results\nggplot(points, aes(x = round, y = points, color = driver_id)) +\n  geom_line() +\n  geom_point(size = 1) +\n  ggtitle(\"Driver Points\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Points\") +\n  theme_dark_f1(axis_marks = TRUE)\n\n\n\nTotal points for each driver after each Grand Prix in the 2021 season\n\n\nBoth of these are a bit hard to read and use driver_id values that aren’t pretty on the plot. We can use some of the FastF1 look-up functions to improve our graphics (recalling that Kubica raced for Alfa Romeo for races 13 & 14 mid-season). We’ll first build a data.frame of all drivers and styles for the season, and join that to the points data.frame after we generate driver abbreviations from the Jolpica driver_id.\ndriver_style &lt;- rbind(\n  get_session_drivers_and_teams(2021, round = 1),\n  get_session_drivers_and_teams(2021, round = 13)\n) %&gt;%\n  unique()\n\ndriver_style$linestyle &lt;- driver_style$marker &lt;- driver_style$color &lt;- driver_style$abbreviation &lt;- NA\n\nfor (i in seq_along(driver_style$name)) {\n  if (driver_style$name[i] == \"Robert Kubica\") {\n    # Manually handling Kubica\n    style &lt;- get_driver_style(driver_style$name[i], season = 2021, round = 13)\n    driver_style$color[i] &lt;- style$color\n    driver_style$marker[i] &lt;- 2\n    driver_style$linestyle[i] &lt;- \"dotted\"\n    driver_style$abbreviation[i] &lt;- style$abbreviation\n  } else {\n    style &lt;- get_driver_style(driver_style$name[i], season = 2021, round = 1)\n    driver_style$color[i] &lt;- style$color\n    driver_style$marker[i] &lt;- style$marker\n    driver_style$linestyle[i] &lt;- style$linestyle\n    driver_style$abbreviation[i] &lt;- style$abbreviation\n  }\n}\n\ncolor_values &lt;- driver_style$color\nnames(color_values) &lt;- driver_style$abbreviation\n\nmarker_values &lt;- driver_style$marker\nnames(marker_values) &lt;- driver_style$abbreviation\n\nlinestyle_values &lt;- driver_style$linestyle\nnames(linestyle_values) &lt;- driver_style$abbreviation\n\npoints &lt;- dplyr::left_join(points, load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\")\nWith our data having graphical and label information added, we can remake these plots:\nggplot(points, aes(x = round, y = points, color = code, shape = code, linetype = code)) +\n  geom_line() +\n  geom_point() +\n  scale_color_manual(name = \"Driver\", values = color_values, aesthetics = c(\"color\", \"fill\")) +\n  scale_shape_manual(name = \"Driver\", values = marker_values) +\n  scale_linetype_manual(name = \"Driver\", values = linestyle_values) +\n  ggtitle(\"Driver Points\", subtitle = \"Through 2021 season\") +\n  xlab(\"Round #\") +\n  ylab(\"Points\") +\n  theme_dark_f1(axis_marks = TRUE)\n\n\n\nRemade points plot for each driver after each Grand Prix in the 2021 season, with better driver names and colors"
  },
  {
    "objectID": "f1dataR/vignettes/jolpica-data-analysis.html#driver-lap-time-scatter-plot",
    "href": "f1dataR/vignettes/jolpica-data-analysis.html#driver-lap-time-scatter-plot",
    "title": "Jolpica Data Analysis",
    "section": "Driver Lap Time Scatter Plot",
    "text": "Driver Lap Time Scatter Plot\nWe can look at a scatterplot of a driver’s laptimes throughout a race - possibly observing the effect of fuel usage, tire wear, pit stops, and race conditions. We’ll also show extracting constructor colour from the built-in data set.\n# Load the laps data and select one driver (this time - Russell)\nbot &lt;- load_laps(season = 2021, round = 4) %&gt;%\n  filter(driver_id == \"bottas\")\n\n# Get Grand Prix Name\nracename &lt;- load_schedule(2021) %&gt;%\n  filter(round == 4) %&gt;%\n  pull(\"race_name\")\n\nracename &lt;- paste(racename, \"2021\")\n\n# Plot the results\nggplot(bot, aes(x = lap, y = time_sec)) +\n  geom_point(color = get_driver_color(\"Bottas\", 2021, 4)) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"Bottas Lap times through the Grand Prix\", subtitle = racename) +\n  xlab(\"Lap Number\") +\n  ylab(\"Lap Time (s)\")\n\n\n\nLaptimes for George Russell, for each lap from the 2021 Spanish Grand Prix\n\n\nWe can see the most of Bottas’ laps were less than 90 seconds. Note a safety car had occurred around lap 8.\nWith the above data, we can also visualize all driver’s laptimes with violin plots. We’ll trim the laptimes to exclude anything above 100 seconds to make the variation in lap time easier to see (i.e. show only racing laps). We can recycle the color values we produced above.\n# Load the laps data (cached!) and filter\nlaps &lt;- load_laps(season = 2021, round = 4) %&gt;%\n  filter(time_sec &lt; 100) %&gt;%\n  group_by(driver_id) %&gt;%\n  mutate(driver_avg = mean(time_sec)) %&gt;%\n  ungroup() %&gt;%\n  left_join(load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\") %&gt;%\n  mutate(code = factor(code, unique(code[order(driver_avg)])))\n\nggplot(laps, aes(x = code, y = time_sec, color = code, fill = code)) +\n  geom_violin(trim = FALSE) +\n  scale_color_manual(\"Driver\", values = color_values, aesthetics = c(\"color\", \"fill\")) +\n  geom_boxplot(width = 0.1, color = \"black\", fill = \"white\", outlier.shape = NA) +\n  theme_dark_f1(axis_marks = TRUE) +\n  ggtitle(\"Driver Lap Times\", subtitle = paste(\"Racing Laps Only -\", racename)) +\n  xlab(\"Driver ID\") +\n  ylab(\"Lap Time (s)\") +\n  theme(axis.text.x = element_text(angle = 90), legend.position = \"\")\n\n\n\nLaptime distributions for all drivers from the 2021 Spanish Grand Prix (racing laps only)"
  },
  {
    "objectID": "f1dataR/vignettes/jolpica-data-analysis.html#compare-qualifying-times",
    "href": "f1dataR/vignettes/jolpica-data-analysis.html#compare-qualifying-times",
    "title": "Jolpica Data Analysis",
    "section": "Compare Qualifying Times",
    "text": "Compare Qualifying Times\nWe can compare the qualifying times for all drivers from a Grand Prix. There’s naturally a few ways to do this (pick each driver’s fastest time, pick each driver’s fastest time from the last session they participated in, etc), all with pros or cons. Rerunning this analysis with different ways of handling the data could produce different results!\n# Load the Data\nquali &lt;- load_quali(2021, 8)\n\n# Get Grand Prix Name\nracename &lt;- load_schedule(2021) %&gt;%\n  filter(round == 8) %&gt;%\n  pull(\"race_name\")\n\n# Process the Data\nquali &lt;- quali %&gt;%\n  summarize(t_min = min(q1_sec, q2_sec, q3_sec, na.rm = TRUE), .by = driver_id) %&gt;%\n  mutate(t_diff = t_min - min(t_min)) %&gt;%\n  left_join(load_drivers(2021)[, c(\"driver_id\", \"code\")], by = \"driver_id\") %&gt;%\n  mutate(code = factor(code, unique(code[order(-t_min)])))\n\n# Plot the results\nggplot(quali, aes(x = code, y = t_diff, color = code, fill = code)) +\n  geom_col() +\n  coord_flip() +\n  ggtitle(paste0(racename, \" 2021 Quali Time Comparison\"),\n    subtitle = paste(\"VER Pole time:\", min(quali$t_min), \"s\")\n  ) +\n  scale_color_manual(values = color_values, aesthetics = c(\"fill\", \"color\")) +\n  ylab(\"Gap to Pole (s)\") +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(legend.position = \"\")\n\n\n\nGap to Pole at the end of qualifying for the 2021 Styrian Grand Prix"
  },
  {
    "objectID": "f1dataR/inst/doc/alonso-penalty-2024.html",
    "href": "f1dataR/inst/doc/alonso-penalty-2024.html",
    "title": "Alonso’s Penalty in the Australian GP 2024",
    "section": "",
    "text": "In the closing laps of the 2024 Australian Grand Prix, the lone remaining Mercedes of George Russell was in a showdown with Aston Martin’s Fernando Alonso. On the penultimate lap, Russell crashed out at turn 6-7, coming to a stop at an awkward angle and askew across the track. Following the race, both drivers were called to the Stewards, who discussed the incident with both drivers and reviewed data and video. They handed Alonso a 20 second penalty for causing the crash, despite there not having been any contact between the two drivers. A large portion of the decision rested on the telemetry from the drivers’ cars. While the Stewards, FIA and teams have much more detailed data than we do, we can repeat their analysis using R, f1dataR and the Python FastF1 package.\n\nAccessing the Data\nWe’ll start by loading the f1dataR package, and preparing the Python virtual environment (including installing FastF1). This happens automatically with a call to setup_fastf1(), see the setup_fastf1 vignette for more information.\nlibrary(f1dataR)\nsetup_fastf1()\nSince the crash occurred on lap 57, we’ll download telemetry for Alonso for the five previous laps to compare what Alonso did on the fateful lap compared to those before. We’ll also load Russell’s telemetry from those same laps to see how he reacts before the crash. Note we use some dplyr for data manipulation.\nalo_telem &lt;- dplyr::bind_rows(lapply(c(52:57), function(l) load_driver_telemetry(season = 2024, round = \"Australia\", session = \"R\", driver = \"ALO\", laps = l) %&gt;% dplyr::mutate(lap = l)))\nrus_telem &lt;- dplyr::bind_rows(lapply(c(52:57), function(l) load_driver_telemetry(season = 2024, round = \"Australia\", session = \"R\", driver = \"RUS\", laps = l) %&gt;% dplyr::mutate(lap = l)))\nA few manipulations now will make later plotting easier:\nalo_telem$lap &lt;- as.factor(alo_telem$lap)\nalo_telem$brake &lt;- as.integer(alo_telem$brake)\nrus_telem$lap &lt;- as.factor(rus_telem$lap)\nrus_telem$brake &lt;- as.integer(rus_telem$brake)\n\n\nTelemetry Review\nAlonso stated he had some challenges with his car (specifically the ERS deployment system, according to an interview he did with Sky Sports as reported on f1.com). But if we look at the telemetry from Alonso comparing lap 57 to the previous, we see the following (focusing on the T6-7 area from 1500 to 2000 m into the lap):\nggplot2::ggplot(alo_telem, ggplot2::aes(x = distance, y = throttle, color = lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::ggtitle(\"Alonso Throttle % by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(\"Throttle %\") +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 3489 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nThrottle Percent by Distance, per lap, for Fernando Alonso at the 2024 Australian GP\n\n\nIn this plot we can see that he let off the throttle about 180 m before any other lap, and had to put some throttle back on before the normal braking point. This doesn’t line up with someone suffering from ERS deployment, but instead an intentional effort to drive the car differently then in the previous laps.\nSimilarly, we can look at braking (on/off), selected gear, and speed traces to see all the changes in driving style for that lap:\nlong_telem_alo &lt;- alo_telem %&gt;%\n  dplyr::select(c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"lap\", \"distance\")) %&gt;%\n  tidyr::pivot_longer(\n    cols = c(\"speed\", \"n_gear\", \"throttle\", \"brake\"),\n    names_to = \"param\",\n    values_to = \"value\"\n  ) %&gt;%\n  dplyr::mutate(param = dplyr::case_match(\n    param,\n    \"speed\" ~ \"Speed (kph)\",\n    \"n_gear\" ~ \"Gear\",\n    \"throttle\" ~ \"Throttle %\",\n    \"brake\" ~ \"Brake (on/off)\"\n  )) %&gt;%\n  dplyr::rename(\"Lap\" = \"lap\") %&gt;%\n  dplyr::mutate(param = factor(param, c(\"Speed (kph)\", \"Throttle %\", \"Gear\", \"Brake (on/off)\")))\n\nggplot2::ggplot(long_telem_alo, ggplot2::aes(x = distance, y = value, color = Lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::facet_grid(rows = ggplot2::vars(param), scales = \"free\") +\n  ggplot2::ggtitle(\"Alonso Telemetry by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(NULL) +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 13956 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nTelemetry (Speed, Throttle, Gear, Brake) by Distance, per lap, for Fernando Alonso at the 2024 Australian GP\n\n\nAlonso, at the Stewards visit, claimed intent to drive a different line at T6 (Stewards document, reported on f1.com). This aligns better with the telemetry, there are multiple actions going on (reduction of throttle, application of brake, downshift) that indicate that the reduction of speed was intentional (and poorly timed, he had to accelerate a bit to get into the corner).\n\n\nEffect on Russell\nRussell, of course, was tailing Alonso, and the telemetry provides a (calculated/interpolated) distance behind the driver in front. We can observe this (with his other telemetry lines too).\nlong_telem_rus &lt;- rus_telem %&gt;%\n  dplyr::select(c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"lap\", \"distance\", \"distance_to_driver_ahead\")) %&gt;%\n  tidyr::pivot_longer(\n    cols = c(\"speed\", \"n_gear\", \"throttle\", \"brake\", \"distance_to_driver_ahead\"),\n    names_to = \"param\",\n    values_to = \"value\"\n  ) %&gt;%\n  dplyr::filter(!(param == \"distance_to_driver_ahead\" & value &gt; 50)) %&gt;%\n  dplyr::mutate(param = dplyr::case_match(\n    param,\n    \"speed\" ~ \"Speed (kph)\",\n    \"n_gear\" ~ \"Gear\",\n    \"throttle\" ~ \"Throttle %\",\n    \"brake\" ~ \"Brake (on/off)\",\n    \"distance_to_driver_ahead\" ~ \"Gap (m)\"\n  )) %&gt;%\n  dplyr::rename(\"Lap\" = \"lap\") %&gt;%\n  dplyr::mutate(param = factor(param, c(\"Gap (m)\", \"Speed (kph)\", \"Throttle %\", \"Gear\", \"Brake (on/off)\")))\n\nggplot2::ggplot(long_telem_rus, ggplot2::aes(x = distance, y = value, color = Lap)) +\n  ggplot2::geom_path() +\n  ggplot2::scale_color_viridis_d() +\n  f1dataR::theme_dark_f1(axis_marks = T) +\n  ggplot2::facet_grid(rows = ggplot2::vars(param), scales = \"free\") +\n  ggplot2::ggtitle(\"Russell Telemetry by Distance, per Lap\", subtitle = \"At the 2024 Australian Grand Prix\") +\n  ggplot2::xlab(\"Distance (m) into lap\") +\n  ggplot2::ylab(NULL) +\n  ggplot2::xlim(c(1500, 2000))\n#&gt; Warning: Removed 13834 rows containing missing values or values outside the scale range\n#&gt; (`geom_path()`).\n\n\n\nTelemetry (Speed, Throttle, Gear, Brake, and Gap to Alonso) by Distance, per lap, for George Russell at the 2024 Australian GP\n\n\nYou can see a sudden and dramatic decrease in the distance between Alonso and Russell in lap 57 (starting around 1575 m). Russell reacted by applying brake earlier than other laps (by a few meters) and was off the throttle earlier than most laps. It was 1.271 s between when Alonso and Russel let off the throttle.\nRussell didn’t expect Alonso to do this move there. The Stewards’ decision rested on the lack of predictability of Alonso. There’s typically only one line through turns 6 & 7, compromising your speed anywhere leaves you vulnerable down the road. Our telemetry access doesn’t provide enough detail to prove that the decrease in distance between the cars caused the problem (all we can see is they got to within 18.6 m, but the replays made it look much closer). Would this have been a penalty if Russell hadn’t crashed? Should Russell have reacted quicker?\n\n\nLimitations\nThere’s key limitations in this data - the most significant being that it’s at a resolution of only about 4 Hertz. The nuances of car gap, reaction times, etc. are all lost in the coarse data we have access to. The FIA, Teams, and Stewards have a much higher resolution available, with many additional data sources too. They also have the testimony of the teams and drivers to consider in their decision, and lots of video sources.\nFor more information on this, read the Stewards’ documents,"
  },
  {
    "objectID": "f1dataR/inst/doc/introduction.html",
    "href": "f1dataR/inst/doc/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "f1dataR serves as a tool to get neatly organized Formula 1 data into your R environment. Here we will go over the basic functions to understand how the package works.\nThe most sought-after aspect of F1 data is telemetry data. Let’s get Leclerc’s fastest lap from the first race of 2022:\nlibrary(f1dataR)\n\nload_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\n#&gt; # A tibble: 697 × 19\n#&gt;    date                session_time  time   rpm speed n_gear throttle brake   drs source       \n#&gt;    &lt;dttm&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;        \n#&gt;  1 2022-03-19 15:58:18        4397. 0     10514   292      7      100 FALSE    12 interpolation\n#&gt;  2 2022-03-19 15:58:18        4397. 0.084 10502   293      7      100 FALSE    12 pos          \n#&gt;  3 2022-03-19 15:58:18        4398. 0.152 10478   294      8      100 FALSE    12 car          \n#&gt;  4 2022-03-19 15:58:18        4398. 0.384 10519   295      8      100 FALSE    12 pos          \n#&gt;  5 2022-03-19 15:58:18        4398. 0.392 10560   296      8      100 FALSE    12 car          \n#&gt;  6 2022-03-19 15:58:19        4398. 0.784 10628   297      8      100 FALSE    12 pos          \n#&gt;  7 2022-03-19 15:58:19        4398. 0.792 10696   299      8      100 FALSE    12 car          \n#&gt;  8 2022-03-19 15:58:19        4398. 0.952 10696   300      8      100 FALSE    12 car          \n#&gt;  9 2022-03-19 15:58:19        4398. 1.02  10734   301      8      100 FALSE    12 pos          \n#&gt; 10 2022-03-19 15:58:19        4399. 1.32  10773   302      8      100 FALSE    12 pos          \n#&gt; # ℹ 687 more rows\n#&gt; # ℹ 9 more variables: relative_distance &lt;dbl&gt;, status &lt;chr&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;, z &lt;dbl&gt;,\n#&gt; #   distance &lt;dbl&gt;, driver_ahead &lt;chr&gt;, distance_to_driver_ahead &lt;dbl&gt;, driver_code &lt;chr&gt;\nNow let’s use ggplot2 to visualize some of the data we have\nlibrary(dplyr)\nlibrary(ggplot2)\n\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\") %&gt;%\n  head(300)\n\nggplot(lec, aes(distance, throttle)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nPlot of lap distance vs throttle percentage for Leclerc at the 2022 Bahrain Grand Prix Qualifying session (specifically his fastest lap)\n\n\nWhat if we get more drivers involved. Let’s also get the Qualifying data from Hamilton and Pérez\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\") %&gt;%\n  head(300)\n\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\") %&gt;%\n  head(300)\n\ndata &lt;- bind_rows(lec, ham, per)\n\nggplot(data, aes(distance, throttle, color = driver_code)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nThrottle percent by distance for Leclerc, Hamilton and Perez from 2022 Bahrain Grand Prix Qualifying session"
  },
  {
    "objectID": "f1dataR/inst/doc/introduction.html#basics",
    "href": "f1dataR/inst/doc/introduction.html#basics",
    "title": "Introduction",
    "section": "",
    "text": "f1dataR serves as a tool to get neatly organized Formula 1 data into your R environment. Here we will go over the basic functions to understand how the package works.\nThe most sought-after aspect of F1 data is telemetry data. Let’s get Leclerc’s fastest lap from the first race of 2022:\nlibrary(f1dataR)\n\nload_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\")\n#&gt; # A tibble: 697 × 19\n#&gt;    date                session_time  time   rpm speed n_gear throttle brake   drs source       \n#&gt;    &lt;dttm&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;        \n#&gt;  1 2022-03-19 15:58:18        4397. 0     10514   292      7      100 FALSE    12 interpolation\n#&gt;  2 2022-03-19 15:58:18        4397. 0.084 10502   293      7      100 FALSE    12 pos          \n#&gt;  3 2022-03-19 15:58:18        4398. 0.152 10478   294      8      100 FALSE    12 car          \n#&gt;  4 2022-03-19 15:58:18        4398. 0.384 10519   295      8      100 FALSE    12 pos          \n#&gt;  5 2022-03-19 15:58:18        4398. 0.392 10560   296      8      100 FALSE    12 car          \n#&gt;  6 2022-03-19 15:58:19        4398. 0.784 10628   297      8      100 FALSE    12 pos          \n#&gt;  7 2022-03-19 15:58:19        4398. 0.792 10696   299      8      100 FALSE    12 car          \n#&gt;  8 2022-03-19 15:58:19        4398. 0.952 10696   300      8      100 FALSE    12 car          \n#&gt;  9 2022-03-19 15:58:19        4398. 1.02  10734   301      8      100 FALSE    12 pos          \n#&gt; 10 2022-03-19 15:58:19        4399. 1.32  10773   302      8      100 FALSE    12 pos          \n#&gt; # ℹ 687 more rows\n#&gt; # ℹ 9 more variables: relative_distance &lt;dbl&gt;, status &lt;chr&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;, z &lt;dbl&gt;,\n#&gt; #   distance &lt;dbl&gt;, driver_ahead &lt;chr&gt;, distance_to_driver_ahead &lt;dbl&gt;, driver_code &lt;chr&gt;\nNow let’s use ggplot2 to visualize some of the data we have\nlibrary(dplyr)\nlibrary(ggplot2)\n\nlec &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"LEC\", laps = \"fastest\") %&gt;%\n  head(300)\n\nggplot(lec, aes(distance, throttle)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nPlot of lap distance vs throttle percentage for Leclerc at the 2022 Bahrain Grand Prix Qualifying session (specifically his fastest lap)\n\n\nWhat if we get more drivers involved. Let’s also get the Qualifying data from Hamilton and Pérez\nham &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"HAM\", laps = \"fastest\") %&gt;%\n  head(300)\n\nper &lt;- load_driver_telemetry(2022, 1, \"Q\", driver = \"PER\", laps = \"fastest\") %&gt;%\n  head(300)\n\ndata &lt;- bind_rows(lec, ham, per)\n\nggplot(data, aes(distance, throttle, color = driver_code)) +\n  geom_line() +\n  theme_minimal()\n\n\n\nThrottle percent by distance for Leclerc, Hamilton and Perez from 2022 Bahrain Grand Prix Qualifying session"
  },
  {
    "objectID": "f1dataR/inst/doc/introduction.html#integrated-plotting",
    "href": "f1dataR/inst/doc/introduction.html#integrated-plotting",
    "title": "Introduction",
    "section": "Integrated plotting",
    "text": "Integrated plotting\nThere are a couple of functions in the package that help with plotting. The first one is theme_dark_f1() that simply applies a theme similar to the official F1 graphics. We can apply it to our previous data.\nggplot(data, aes(distance, speed, color = driver_code)) +\n  geom_line() +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(\n    axis.title = element_text(),\n    axis.line = element_line(color = \"white\"),\n  ) +\n  labs(\n    title = \"Speed Comparison for Bahrain 2022\"\n  )\n\n\n\nThrottle percent by distance for the three drivers, with f1dataR theme applied\n\n\nAnother built-in function is plot_fastest() that can plot the speed or gear changes throughout the fastest lap for a driver/race.\nplot_fastest(2022, 1, \"R\", \"PER\")\n#&gt; ℹ If the session has not been loaded yet, this could take a minute\n\n\n\nFastest lap for Perez from the 2022 Bahrain Grand Prix, showing gear used at each point in the lap"
  },
  {
    "objectID": "f1dataR/inst/doc/introduction.html#combining-several-functions",
    "href": "f1dataR/inst/doc/introduction.html#combining-several-functions",
    "title": "Introduction",
    "section": "Combining several functions",
    "text": "Combining several functions\nNow let’s look at a more complete analysis. We want to visualize how lap time change over time (tyre age) for Pérez with every compound used in the Spanish GP.\nlaps &lt;- load_session_laps(2023, \"Spain\") %&gt;%\n  filter(driver == \"PER\") %&gt;%\n  group_by(compound) %&gt;%\n  # Remove in and out laps\n  filter(tyre_life != 1 & tyre_life != max(tyre_life)) %&gt;%\n  ungroup()\n\nggplot(laps, aes(tyre_life, lap_time, color = compound)) +\n  geom_line() +\n  geom_point() +\n  theme_dark_f1(axis_marks = TRUE) +\n  labs(\n    color = \"Tyre Compound\",\n    y = \"Lap Time (Seconds)\",\n    x = \"Tyre Life (Laps)\"\n  ) +\n  scale_color_manual(\n    values = c(\"white\", \"yellow\", \"red\")\n  ) +\n  scale_y_continuous(breaks = seq(75, 85, 1)) +\n  scale_x_continuous(breaks = seq(2, 26, 4))\n\n\n\nAverage laptime per tyre type and age at Spanish Grand Prix 2023\n\n\nNow let’s visualize the portion of the track where Verstappen had the throttle 100% open in the 2023 Canadian GP. Note that we’ll pass the plot through the helper function correct_track_ratio() to ensure the plotted track has correct dimensions (and a few other tweaks for pretty plotting). Alternatively, you can call ggplot2::coord_fixed() while building track plots to ensure the x & y ratios are equal.\nver_can &lt;- load_driver_telemetry(\n  season = 2023,\n  round = \"Canada\",\n  driver = \"VER\",\n  laps = \"fastest\"\n) %&gt;%\n  mutate(open_throttle = ifelse(throttle == 100, \"Yes\", \"No\"))\n\nthrottle_plot &lt;- ggplot(ver_can, aes(x, y, color = as.factor(open_throttle), group = NA)) +\n  geom_path(linewidth = 4, lineend = \"round\") +\n  scale_color_manual(values = c(\"white\", \"red\")) +\n  theme_dark_f1() +\n  labs(\n    title = \"Verstappen Flat Out\",\n    subtitle = \"Canada 2023 | Fastest Lap\",\n    color = \"Throttle 100%\"\n  )\n\ncorrect_track_ratio(throttle_plot)\n\n\n\nVerstappen fastest lab in the Canadian Grand Prix 2023, showing full throttle sections\n\n\nFor a simpler visualization let’s look at the average time it took each team to pit in round 4 of 2023. For this we will have to load the pit data, the results data (to extract driver + team combos), and read the constructor data to get the colors for our plot. Note the time is the difference from pit entry to exit, not stopped time.\npit_data &lt;- load_pitstops(2023, 4)\n\ndriver_team &lt;- load_results(2023, 4) %&gt;%\n  select(driver_id, constructor_id)\n\npit_constructor &lt;- pit_data %&gt;%\n  left_join(driver_team, by = \"driver_id\") %&gt;%\n  group_by(constructor_id) %&gt;%\n  summarise(pit_time = mean(as.numeric(duration)))\n\npit_constructor$constructor_color &lt;- sapply(pit_constructor$constructor_id, get_team_color, season = 2023, round = 4, USE.NAMES = FALSE)\n\npit_constructor$team_name &lt;- sapply(pit_constructor$constructor_id, get_team_name, season = 2023, short = TRUE, USE.NAMES = FALSE)\n\nggplot(pit_constructor, aes(x = team_name, y = pit_time, fill = team_name)) +\n  geom_bar(stat = \"identity\", fill = pit_constructor$constructor_color) +\n  theme_dark_f1(axis_marks = TRUE) +\n  theme(\n    legend.position = \"none\"\n  ) +\n  labs(\n    x = \"Constructor\",\n    y = \"Average Pit Time (seconds)\"\n  ) +\n  ggtitle(\"Average time in pit lane for each team\", subtitle = \"Azerbaijan Grand Prix 2023\")\n\n\n\nAverage time in pits for each team at the 2023 Azerbaijan Grand Prix"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sportsblog",
    "section": "",
    "text": "SEC 2024 : Alabama vs Georgia\n\n\n\n\n\n\nfootball\n\n\nSEC\n\n\nAlabama\n\n\nGeorgia\n\n\n\n\n\n\n\n\n\nApr 1, 2025\n\n\nAspen Raine Reynolds\n\n\n\n\n\n\nNo matching items"
  }
]